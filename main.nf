#!/usr/bin/env nextflow
nextflow.enable.dsl = 2

date = new Date().format('yyMMdd')
user = "$USER"
runID = "${date}.${user}"


//Unset parameters
params.help                     = false
params.panel                    = null
params.samplesheet              = null
params.preprocessOnly           = null
params.keepwork                 = null
params.nomail                   = null
params.hg38v1                   = null
params.hg38v2                   = null
params.cram                     = null
params.fastq                    = null
params.archiveStorage           = null
params.lnx01_storage            = null
params.skipSpliceAI             = null
params.skipJointGenotyping      = null
params.fastqInput               = null
params.skipSV                   = null
params.skipVariants             = null
params.skipQC                   = null
params.skipSTR                  = null
params.skipSMN                  = null
// Preset parameters:
params.gatk                     = null
params.copyCram                 = null
params.single                   = null
params.server                   = "lnx01"
params.genome                   = "hg38"
params.outdir                   = "${launchDir.baseName}.Results"
params.rundir                   = "${launchDir.baseName}"
//params.intervals_list          = "/data/shared/genomes/hg38/interval.files/WGS_splitIntervals/wgs_splitinterval_BWI_subdivision3/*.interval_list";


/* --------------------------
   Helper / Error messages
   -------------------------- */
def helpMessage() {
    log.info """
    Usage:

    KG Vejle Germline script (WGS, WES or panels)

    PANEL ANALYSIS:
    See https://github.com/KGVejle/germlineNGS for a description of the most common usecases

    WGS ANALYSIS:

    Example samplesheet for standard trio:
    johnDoe 123456789012    index   affected
    johnDoe 234567890123    mater   normal
    johnDoe 345678901234    pater   normal

    The above information can usually be extracted directly from the sample overview excel file

    If the inputdata (FastQ or CRAM) have been transferred to the data archive (which it is by default),
    the script will automatically find the relevant inputdata and create symlinks for them in the output (results) directory.

    The script will automatically look for FastQ or CRAM files in subfolders at /lnx01_data2/shared/dataArchive/.
    This location contains read-only access to the data archive, containing all FastQ and CRAM files.
    There's no need to copy or move any data.

    The user can point to a specific folder containing raw data (FastQ) using the --fastq option
    or alignment data (CRAM) using the --cram option.
    This is only needed if input data (FastQ or CRAM) exists outside the data archive
    (e.g. if data are in personal folders), or if the script is run without samplesheet.

    If the script is run without samplesheet, the user MUST point to a folder containing inputdata
    with either the --fastq or --cram option.

    Main options:
      --help            Print this help message

      --genome          hg19 or hg38
                            Default: hg38 v3 (masked + decoys)

      --hg38v1          Use primary (full) hg38 assembly (UCSC primary).

      --hg38v2          Use hg38 v2 (ucsc.hg38.NGS.analysisSet.fa).

      --gatk            "danak" (v.4.1.9) or "new" (v.4.4.0.0)
                            Default: danak

      --samplesheet     Path to samplesheet for samples to be analyzed (Only required for WGS analysis)

      --fastq           Path to folder with wgs fastq files
                            Default: /lnx01_data2/shared/dataArchive/{all subfolders}

      --fastqInput      Use fastq as input (i.e. perform trimming, and alignment)
                            Default: Not set - use CRAM as input.

      --cram            Path to folder with wgs CRAM files
                            Default: /lnx01_data2/shared/dataArchive/{all subfolders}

      --outdir          Manually set output directory
                            Default: {current_dir}.Results

      --keepwork        keep the workfolder generated by the nextflow script.
                            Default: Not set - removes the Work folder

      --nomail          Does not send a mail-message when completing a script
                            Default: Not set - sends mail message if the user is mmaj or raspau
                            and only if the script has been running longer than 20 minutes.

      --panel           Type of paneldata to analyze. Currently supports AV1, CV5 and MV1
                            Default: Not set - assumes WGS data by default


    WGS Analysis: Select or modify analysis steps:

      --skipVariants    Do not call SNPs and INDELs at all
                            Default: Call SNPs and INDELs using GATK HaplotypeCaller

      --skipSV          Do not call Structural Variants (SV incl. CNVs) at all
                            Default: Call SVs using Manta, Lumpy, CNVNator and CNVKit

      --skipSTR         Do not call repeat expansions.
                            Default: Calls repeat expansions using Stripy and ExpansionHunter

      --skipQC          Do not run QC module (e.g. Picard Metrics, samtools, multiQC etc.)
                            Default: Run QC module

      --skipSMN         Do not call SMN1 and SMN2 variants
                            Default: Call SMN variants with SMNCopyNumberCaller
    """.stripIndent()
}
if (params.help) exit 0, helpMessage()

def errorMessage1() {
    log.info """
    USER INPUT ERROR: If no samplesheet is selected, the user needs to point to a folder containing
    relevant fastq or CRAM files...
    Run the script with the --help parameter to see available options
    """.stripIndent()
}
if (!params.samplesheet && !params.fastq && !params.cram) exit 0, errorMessage1()

def FastqCRAM_error() {
    log.info """
    USER INPUT ERROR: The user should point to either FastQ (--fastq parameter) or CRAM (--cram parameter)
    as input - not both!
    """.stripIndent()
}
if (params.cram && params.fastq) exit 0, FastqCRAM_error()


/* --------------------------
   Set up server & data paths
   -------------------------- */
switch (params.server) {
    case 'lnx02':
        dataArchive = "/lnx01_data2/shared/dataArchive"
        break

    case 'lnx01':
        modules_dir    = "/home/mmaj/scripts_lnx01/nextflow_lnx01/dsl2/modules"
        subworkflow_dir= "/home/mmaj/scripts_lnx01/nextflow_lnx01/dsl2/subworkflows"
        dataArchive    = "/lnx01_data2/shared/dataArchive"
        break

    case 'kga01':
        modules_dir    = "/home/mmaj/LNX01_mmaj/scripts_lnx01/nextflow_lnx01/dsl2/modules"
        subworkflow_dir= "/home/mmaj/LNX01_mmaj/scripts_lnx01/nextflow_lnx01/dsl2/subworkflows"
        dataArchive    = "/data/shared/dataArchive"
        break
}


/* --------------------------
   Set up patterns for panel
   -------------------------- */
switch (params.panel) {

    case "AV1":
        reads_pattern_cram  = "*{.,-,_}{AV1}{.,-,_}*.cram"
        reads_pattern_crai  = "*{.,-,_}{AV1}{.,-,_}*.crai"
        reads_pattern_fastq = "*{.,-,_}{AV1}{.,-,_}*R{1,2}*{fq,fastq}.gz"
        panelID = "AV1"
        break

    case "CV5":
        reads_pattern_cram  = "*{.,-,_}{CV5}{.,-,_}*.cram"
        reads_pattern_crai  = "*{.,-,_}{CV5}{.,-,_}*.crai"
        reads_pattern_fastq = "*{.,-,_}{CV5}{.,-,_}*R{1,2}*{fq,fastq}.gz"
        panelID = "CV5"
        break

    case "GV3":
        reads_pattern_cram  = "*{GV1,GV2,GV3}*.cram"
        reads_pattern_crai  = "*{GV1,GV2,GV3}*.crai"
        reads_pattern_fastq = "*{GV1,GV2,GV3}*R{1,2}*{fq,fastq}.gz"
        panelID = "GV3"
        break

    case "GV_TEST":
        reads_pattern_cram  = "*.cram"
        reads_pattern_crai  = "*.crai"
        reads_pattern_fastq = "*R{1,2}*{fq,fastq}.gz"
        panelID = "GV_TEST"
        break

    case "MV1":
        reads_pattern_cram  = "*{MV1}*.cram"
        reads_pattern_crai  = "*{MV1}*.crai"
        reads_pattern_fastq = "*{MV1}*R{1,2}*{fq,fastq}.gz"
        panelID = "MV1"
        break

    case "WES_2":
        reads_pattern_cram  = "*{-,.,_}{EV8,EV7,EV6}{-,.,_}*.cram"
        reads_pattern_crai  = "*{-,.,_}{EV8,EV7,EV6}{-,.,_}*.crai"
        reads_pattern_fastq = "*{-,.,_}{EV8,EV7,EV6}{-,.,_}*R{1,2}*{fq,fastq}.gz"
        panelID = "WES"
        break

    case "WES":
        reads_pattern_cram  = "*{-,.,_}{EV8_ALM,EV8_ONK}{-,.,_}*.cram"
        reads_pattern_crai  = "*{-,.,_}{EV8_ALM,EV8_ONK}{-,.,_}*.crai"
        reads_pattern_fastq = "*{-,.,_}{EV8_ALM,EV8_ONK}{-,.,_}*R{1,2}*{fq,fastq}.gz"
        panelID = "WES_subpanel"
        break

    case "WGS_CNV":
        reads_pattern_cram  = "*{-,.,_}{WG4_CNV}{-,.,_}*.cram"
        reads_pattern_crai  = "*{-,.,_}{WG4_CNV}{-,.,_}*.crai"
        reads_pattern_fastq = "*{-,.,_}{WG4_CNV}{-,.,_}*R{1,2}*{fq,fastq}.gz"
        panelID = "WGS"
        break

    default:
        reads_pattern_cram  = "*{-,.,_}{WG3,WG4,A_WG4,LIB,WG4_CNV,WGSmerged}{-,.,_}*.cram"
        reads_pattern_crai  = "*{-,.,_}{WG3,WG4,A_WG4,LIB,WG4_CNV,WGSmerged}{-,.,_}*.crai"
        reads_pattern_fastq = "*{-,.,_}{WG3,WG4,A_WG4,LIB,WG4_CNV,WGSmerged,WGS}{-,.,_}*R{1,2}*{fq,fastq}.gz"
        panelID = "WGS"
        break
}


/* ----------------------------------------
   INPUT DATA (fastq or CRAM) channel setup
   ---------------------------------------- */

// If the user sets `--fastqInput` but doesn't provide `--fastq`, default to searching in dataArchive
if (!params.fastq && params.fastqInput) {
    params.reads = "${dataArchive}/{lnx01,lnx02,kga01_novaRuns,tank_kga_external_archive}/**/${reads_pattern_fastq}"
}


// If NOT samplesheet but fastq is given
if (!params.samplesheet && params.fastq) {
    params.reads = "${params.fastq}/${reads_pattern_fastq}"

    Channel
        .fromPath(params.reads, checkIfExists: true)
        .filter { it =~ /R1/ }
        .map { tuple(it.baseName.tokenize('-').get(0) + "_" + it.baseName.tokenize('-').get(1), it) }
        .set { sampleid_R1 }

    Channel
        .fromPath(params.reads, checkIfExists: true)
        .filter { it =~ /R2/ }
        .map { tuple(it.baseName.tokenize('-').get(0) + "_" + it.baseName.tokenize('-').get(1), it) }
        .set { sampleid_R2 }

    sampleid_R1.join(sampleid_R2).set { read_pairs_ch }
}


// If samplesheet plus fastq or fastqInput
if (params.samplesheet && params.fastq || params.fastqInput) {
    Channel
        .fromPath(params.reads, checkIfExists: true)
        .filter { it =~ /_R1_/ }
        .map { tuple(it.baseName.tokenize('-').get(0) + "_" + it.baseName.tokenize('-').get(1), it) }
        .set { sampleid_R1 }

    Channel
        .fromPath(params.reads, checkIfExists: true)
        .filter { it =~ /_R2_/ }
        .map { tuple(it.baseName.tokenize('-').get(0) + "_" + it.baseName.tokenize('-').get(1), it) }
        .set { sampleid_R2 }

    sampleid_R1.join(sampleid_R2).set { read_pairs_ch }
}


// If CRAM is provided (explicitly or with a panel)
if (params.cram) {
    cramfiles = "${params.cram}/${reads_pattern_cram}"
    craifiles = "${params.cram}/${reads_pattern_crai}"

    Channel
        .fromPath(cramfiles)
        .map { tuple(it.baseName.tokenize('.').get(0), it) }
        .set { sampleID_cram }

    Channel
        .fromPath(craifiles)
        .map { tuple(it.baseName.tokenize('.').get(0), it) }
        .set { sampleID_crai }
}


// If only samplesheet is provided, use CRAM from archive (default WGS approach)
if (params.samplesheet && !params.cram && !params.fastqInput && !params.fastq) {
    cramfiles = "${dataArchive}/{lnx01,lnx02,tank_kga_external_archive}/**/${reads_pattern_cram}"
    craifiles= "${dataArchive}/{lnx01,lnx02,tank_kga_external_archive}/**/${reads_pattern_crai}"

    Channel
        .fromPath(cramfiles)
        .map { tuple(it.baseName.tokenize('_').get(0), it) }
        .set { sampleID_cram }

    Channel
        .fromPath(craifiles)
        .map { tuple(it.baseName.tokenize('_').get(0), it) }
        .set { sampleID_crai }
}


/* ----------------------------------------
   SAMPLESHEET channels
   ---------------------------------------- */
if (params.samplesheet) {
    channel
        .fromPath(params.samplesheet)
        .splitCsv(sep:'\t')
        .map { row -> tuple(row[1], row[0], row[2], row[3]) }
        .set { full_samplesheet }
    // above: NPN, caseID, relation, samplestatus

    channel
        .fromPath(params.samplesheet)
        .splitCsv(sep:'\t')
        .map { row -> row[0] }
        .unique()
        .collect()
        .set { caseID_ch }

    channel
        .fromPath(params.samplesheet)
        .splitCsv(sep:'\t')
        .map { row -> tuple(row[0], row[1]) }
        .set { caseID_sampleID }
}


/* ----------------------------------------
   FINAL INPUT CHANNELS
   ---------------------------------------- */
if (!params.samplesheet && params.fastq) {
    read_pairs_ch.set { fq_read_input }
}

if (!params.samplesheet && params.cram) {
    sampleID_cram.join(sampleID_crai).set { meta_aln_index }
}

if (params.samplesheet && !params.cram && (params.fastqInput || params.fastq)) {
    full_samplesheet.join(read_pairs_ch)
        .map { tuple(it[0] + "_" + it[1] + "_" + it[2], it[4], it[5]) }
        .set { fq_read_input }
}

if (params.samplesheet && !params.fastqInput && !params.fastq) {
    full_samplesheet.join(sampleID_cram).join(sampleID_crai)
        .map { tuple(it[0] + "_" + it[1] + "_" + it[2], it[4], it[5]) }
        .set { meta_aln_index }
}


/* ----------------------------------------
   (Optional) Haplotypecaller intervals
   ----------------------------------------
channel
    .fromPath(params.intervals_list)
    .map { it -> tuple(it.baseName, it) }
    .set { haplotypecallerIntervalList }
*/


/* ----------------------------------------
   Include DSL2 modules/subworkflows
   ---------------------------------------- */
include {
    // Symlinks:
    inputFiles_symlinks_cram
    inputFiles_cramCopy
    // Preprocess tools:
    // QC tools
    samtools
    qualimap
    fastqc_bam
    collectWGSmetrics
    multiQC
    vntyper_newRef
    // subworkflows
    SUB_PREPROCESS
    SUB_VARIANTCALL
    SUB_VARIANTCALL_WGS
    SUB_CNV_SV
    SUB_STR
    SUB_SMN
} from "./modules/modules.dna.v1.nf"


/* ----------------------------------------
   QC workflow example
   ---------------------------------------- */
workflow QC {
    take: meta_aln_index

    main:
    samtools(meta_aln_index)
    // qualimap(meta_aln_index)
    // fastqc_bam(meta_aln_index)
    multiQC(
        samtools.out.ifEmpty([])
            .mix(qualimap.out.ifEmpty([]))
            .mix(fastqc_bam.out.ifEmpty([]))
            .collect()
    )
}


/* ----------------------------------------
   MAIN WORKFLOW
   ---------------------------------------- */
workflow {

    if (!params.panel || params.panel == "WGS_CNV") {
        if (params.fastqInput || params.fastq) {
            SUB_PREPROCESS(fq_read_input)

            if (!params.preprocessOnly) {
                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(SUB_PREPROCESS.out.finalAln)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(SUB_PREPROCESS.out.finalAln)
                }
                if (!params.skipSTR) {
                    SUB_STR(SUB_PREPROCESS.out.finalAln)
                }
                if (!params.skipSMN) {
                    SUB_SMN(SUB_PREPROCESS.out.finalAln)
                }
            }
        }
        else {
            // CRAM-based approach
            if (!params.copyCram) {
                inputFiles_symlinks_cram(meta_aln_index)

                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(meta_aln_index)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(meta_aln_index)
                }
                if (!params.skipSTR) {
                    SUB_STR(meta_aln_index)
                }
                if (!params.skipSMN) {
                    SUB_SMN(meta_aln_index)
                }
            }
            else {
                // If copying CRAM
                inputFiles_symlinks_cram(meta_aln_index)
                inputFiles_cramCopy(meta_aln_index)

                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(inputFiles_cramCopy.out)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(inputFiles_cramCopy.out)
                }
                if (!params.skipSTR) {
                    SUB_STR(inputFiles_cramCopy.out)
                }
                if (!params.skipSMN) {
                    SUB_SMN(inputFiles_cramCopy.out)
                }
            }
        }
    }

    // Panel logic (not WGS_CNV)
    if (params.panel && params.panel != "WGS_CNV") {
        if (params.fastqInput || params.fastq) {
            SUB_PREPROCESS(fq_read_input)
            SUB_VARIANTCALL(SUB_PREPROCESS.out.finalAln)

            if (params.panel == "MV1") {
                vntyper_newRef(fq_read_input)
            }
        }
        else {
            // CRAM-based panel
            inputFiles_symlinks_cram(meta_aln_index)
            SUB_VARIANTCALL(meta_aln_index)
        }
    }
}


/* ----------------------------------------
   COLLECT SAMPLE NAMES FROM caseID_ch
   ---------------------------------------- */
def sampleNamesList = []

// Because we used `.collect()` in the samplesheet definition,
// `caseID_ch` will emit a single ArrayList of sample IDs once it closes.
caseID_ch.subscribe { allSampleIDs ->
    sampleNamesList = allSampleIDs
}


/* ----------------------------------------
   WORKFLOW ON COMPLETE
   ---------------------------------------- */
workflow.onComplete {
    // Determine the current year dynamically
    def currentYear = new Date().format('yyyy')

    // Read IP address from file
    def ipFilePath = '/lnx01_data2/shared/testdata/test_scripts/ip_file'
    def ip = ""
    if (new File(ipFilePath).exists()) {
        println("IP file exists. Reading IP address.")
        ip = new File(ipFilePath).text.trim()
        println("IP address read from file: ${ip}")
    } else {
        println("Error: IP address file not found at ${ipFilePath}")
        return
    }

    // Turn the collected sample list into a commaâ€separated string
    def sampleNamesString = sampleNamesList.join(', ')

    // Only send email if:
    // --nomail is not specified,
    // user is mmaj or raspau,
    // pipeline ran more than 5 minutes (300000 ms),
    // and pipeline succeeded
    if (!params.nomail && workflow.duration > 300000 && workflow.success) {
        if (System.getenv("USER") in ["raspau", "mmaj"]) {
            def sequencingRun = params.cram
                ? new File(params.cram).getName().take(6)
                : params.fastq
                    ? new File(params.fastq).getName().take(6)
                    : 'Not provided'

            // Checks if there are OBS samples in the cram folder
            def obsSampleMessage = ""
            if (params.panel == "AV1" && params.cram) {
                def cramDir = new File(params.cram)
                def obsSamples = cramDir.listFiles().findAll { it.name.contains("OBS") }
                if (obsSamples.size() > 0) {
                    obsSampleMessage = "\nTHERE IS AN OBS SAMPLE IN THIS RUN"
                }
            }

            def workDirMessage = params.keepwork ? "WorkDir: ${workflow.workDir}" : "WorkDir: Deleted"
            def outputDir      = "${launchDir}/${launchDir.baseName}.Results"

            def body = """\
            Pipeline execution summary
            ---------------------------
            Pipeline completed: ${params.panel}
            Sequencing run: ${sequencingRun}${obsSampleMessage}
            Duration: ${workflow.duration}
            Success: ${workflow.success}
            ${workDirMessage}
            OutputDir: ${outputDir}
            Exit status: ${workflow.exitStatus}
            ${obsSampleMessage}

            Samples included in the pipeline:
            ${sampleNamesString}
            """.stripIndent()

            def recipients = 'Rasmus.Hojrup.Pausgaard@rsyd.dk'

            if (params.server == 'lnx01') {
                // Use Nextflow's built-in sendMail function when on lnx01
                sendMail(to: recipients, subject: 'GermlineNGS pipeline Update', body: body)
            }
            else if (params.server == 'lnx02') {
                // Use external command to send email from lnx02
                def emailCommand = "ssh ${ip} 'echo \"${body}\" | mail -s \"GermlineNGS pipeline Update\" ${recipients}'"
                def emailProcess = ['bash', '-c', emailCommand].execute()
                emailProcess.waitFor()
                if (emailProcess.exitValue() != 0) {
                    println("Error sending email from remote server: ${emailProcess.err.text}")
                } else {
                    println("Email successfully sent from remote server.")
                }
            }

            // If not keeping work, delete it
            if (!params.keepwork) {
                println("Deleting work directory: ${workflow.workDir}")
                def deleteWorkDirCommand = "rm -rf ${workflow.workDir}".execute()
                deleteWorkDirCommand.waitFor()
                if (deleteWorkDirCommand.exitValue() != 0) {
                    println("Error deleting work directory: ${deleteWorkDirCommand.err.text}")
                }
            }

            // Move WGS_CNV from lnx02 to lnx01 if success
            if (params.server == 'lnx02' && params.panel == 'WGS_CNV' && workflow.success) {
                def moveWGSCNVCommand = "mv ${launchDir} /lnx01_data2/shared/patients/hg38/WGS.CNV/${currentYear}/"
                def moveWGSCNVProcess = ['bash', '-c', moveWGSCNVCommand].execute()
                moveWGSCNVProcess.waitFor()
                if (moveWGSCNVProcess.exitValue() != 0) {
                    println("Error moving WGS_CNV files: ${moveWGSCNVProcess.err.text}")
                }
            }

            // Move WES from lnx02 to lnx01 if success
            if (params.server == 'lnx02' && params.panel == 'WES' && workflow.success) {
                def moveWESCommand = "mv ${launchDir} /lnx01_data2/shared/patients/hg38/WES_ALM_ONK/${currentYear}/"
                def moveWESProcess = ['bash', '-c', moveWESCommand].execute()
                moveWESProcess.waitFor()
                if (moveWESProcess.exitValue() != 0) {
                    println("Error moving WES files: ${moveWESProcess.err.text}")
                }
            }
        }
    }
}
