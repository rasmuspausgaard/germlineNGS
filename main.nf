#!/usr/bin/env nextflow
nextflow.enable.dsl = 2


date=new Date().format( 'yyMMdd' )
user="$USER"
runID="${date}.${user}"


//Unset parameters
params.help                     =false
params.panel                    =null
params.samplesheet              =null
params.preprocessOnly           =null
params.keepwork                 =null
params.nomail                   =null
params.hg38v1                   =null
params.hg38v2                   =null
params.cram                     =null
params.fastq                    =null
params.spring                   =null
params.archiveStorage           =null
params.lnx01_storage            =null
params.skipSpliceAI             =null
params.skipJointGenotyping      =null
params.fastqInput               =null
params.skipSV                   =null
params.skipVariants             =null
params.skipQC                   =null
params.skipSTR                  =null
params.skipSMN                  =null
//Preset parameters:
params.gatk                     =null
params.copyCram                 =null
params.single                   =null
params.server                   = "lnx01"
params.genome                   = "hg38"
params.outdir                   = "${launchDir.baseName}.Results"
params.rundir                   = "${launchDir.baseName}"
//params.intervals_list           ="/data/shared/genomes/hg38/interval.files/WGS_splitIntervals/wgs_splitinterval_BWI_subdivision3/*.interval_list";



def helpMessage() {
    log.info"""

    Usage:

    KG Vejle Germline script (WGS, WES or panels)

    PANEL ANALYSIS:
    See https://github.com/KGVejle/germlineNGS for a description of the most common usecases

    WGS ANALYSIS:

    Example samplesheet for standard trio:
    johnDoe 123456789012    index   affected
    johnDoe 234567890123    mater   normal
    johnDoe 345678901234    pater   normal

    The above information can usually be extracted directly from the sample overview excel file

    If the inputdata (FastQ or CRAM) have been transferred to the data archive (which it is by default), the script will automatically find the relevant inputdata  and create symlinks for them in the output (results) directory.

    The script will automatically look for FastQ or CRAM files in subfolders at /lnx01_data2/shared/dataArchive/. This location contains read-only access to the data archive, containing all FastQ and CRAM files. There's no need to copy or move any data.

    The user can point to a specific folder containing raw data (FastQ) using the --fastq option  or alignment data (CRAM) using the --cram option
    This is only needed if input data (FastQ or CRAM) exists outside the data archive (e.g. if data are in personal folders), or if the script is run without samplesheet.

    If the script is run without samplesheet, the user MUST point to a folder containing inputdata with either the --fastq or --cram option.

    Main options:
      --help            Print this help message
      
      --genome          hg19 or hg38
                            Default: hg38 v3 (masked + decoys)

      --hg38v1          Use primary (full) hg38 assembly (UCSC primary).

      --hg38v2          Use hg38 v2 (ucsc.hg38.NGS.analysisSet.fa).

      --gatk            "danak" (v.4.1.9) or "new" (v.4.4.0.0)
                            Default: danak  
      
      --samplesheet     Path to samplesheet for samples to be analyzed (Only required for WGS analysis)
      
      --fastq            Path to folder with wgs fastq files
                            Default: /lnx01_data2/shared/dataArchive/{all subfolders}

      --fastqInput      Use fastq as input (i.e. perform trimming, and alignment)
                            Default: Not set - use CRAM as input.
      
      --cram             Path to folder with wgs CRAM files
                            Default: /lnx01_data2/shared/dataArchive/{all subfolders}
      
      --outdir          Manually set output directory
                            Default: {current_dir}.Results

      --keepwork        keep the workfolder generated by the nextflow script.
                            Default: Not set - removes the Work folder

      --nomail          Does not send a mail-message when completing a script
                            Default: Not set - sends mail message if the user is mmaj or raspau and only if the script has been running longer than 20 minutes.

      --panel           Type of paneldata to analyze. Currently supports AV1, CV5 and MV1
                            Default: Not set - assumes WGS data by dfault


    WGS Analysis: Select or modify analysis steps:

      --skipVariants    Do not call SNPs and INDELs at all
                            Default: Call SNPs and INDELs using GATK HaplotypeCaller

      --skipSV          Do not call Structural Variants (SV incl. CNVs) at all
                            Default: Call SVs using Manta, Lumpy, CNVNator and CNVKit

      --skipSTR         Do not call repeat expansions.
                            Default: Calls repeat expansions using Stripy and ExpansionHunter

      --skipQC          Do not run QC module (e.g. Picard Metrics, samtools, multiQC etc.)
                            Default: Run QC module

      --skipSMN         Do not call SMN1 and SMN2 variants
                            Default: Call SMN variants with SMNCopyNumberCaller

    """.stripIndent()
}
if (params.help) exit 0, helpMessage()

def errorMessage1() {

    log.info"""

    USER INPUT ERROR: If no samplesheet is selected, the user needs to point to a folder containing relevant fastq, CRAM or SPRING files... 
    Run the script with the --help parameter to see available options
    
    """.stripIndent()
}

if (!params.samplesheet && !params.fastq && !params.cram && !params.spring) exit 0, errorMessage1()

def FastqCRAM_error() {
    log.info"""
    USER INPUT ERROR: The user should point to either FastQ (--fastq parameter) or CRAM (--cram parameter) as input - not both! 
    """.stripIndent()
}

if (params.cram && params.fastq) exit 0, FastqCRAM_error()





switch (params.server) {
    case 'lnx02':
       // modules_dir="/home/mmaj/scripts_lnx01/nextflow_lnx01/dsl2/modules";
        //subworkflow_dir="/home/mmaj/scripts_lnx01/nextflow_lnx01/dsl2/subworkflows";
        dataArchive="/lnx01_data2/shared/dataArchive";
    break;

    case 'lnx01':
        modules_dir="/home/mmaj/scripts_lnx01/nextflow_lnx01/dsl2/modules";
        subworkflow_dir="/home/mmaj/scripts_lnx01/nextflow_lnx01/dsl2/subworkflows";
        dataArchive="/lnx01_data2/shared/dataArchive";
    break;
    case 'kga01':
        modules_dir="/home/mmaj/LNX01_mmaj/scripts_lnx01/nextflow_lnx01/dsl2/modules";
        subworkflow_dir="/home/mmaj/LNX01_mmaj/scripts_lnx01/nextflow_lnx01/dsl2/subworkflows";
        dataArchive="/data/shared/dataArchive";

    break;
}



switch (params.panel) {

    case "AV1":
        reads_pattern_cram="*{.,-,_}{AV1}{.,-,_}*.cram";
        reads_pattern_crai="*{.,-,_}{AV1}{.,-,_}*.crai";
        reads_pattern_fastq="*{.,-,_}{AV1}{.,-,_}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*AV1*.spring";
        panelID="AV1"
    break;

    case "CV5":
        reads_pattern_cram="*{.,-,_}{CV5}{.,-,_}*.cram";
        reads_pattern_crai="*{.,-,_}{CV5}{.,-,_}*.crai";
        reads_pattern_fastq="*{.,-,_}{CV5}{.,-,_}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*CV5*.spring";
        panelID="CV5"
    break;

    case "GV3":
        reads_pattern_cram="*{GV1,GV2,GV3}*.cram";
        reads_pattern_crai="*{GV1,GV2,GV3}*.crai";
        reads_pattern_fastq="*{GV1,GV2,GV3}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*{GV1,GV2,GV3}*.spring";
        panelID="GV3"
    break;

    case "GV_TEST":
        reads_pattern_cram="*.cram";
        reads_pattern_crai="*.crai";
        reads_pattern_fastq="*R{1,2}*{fq,fastq}.gz";
        panelID="GV_TEST"
    break;

    case "MV1":
        reads_pattern_cram="*{MV1}*.cram";
        reads_pattern_crai="*{MV1}*.crai";
        reads_pattern_fastq="*{MV1}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*MV1*.spring";
        panelID="MV1"
    break;

    case "WES_2":
        reads_pattern_cram="*{-,.,_}{EV8,EV7,EV6}{-,.,_}*.cram";
        reads_pattern_crai="*{-,.,_}{EV8,EV7,EV6}{-,.,_}*.crai";
        reads_pattern_fastq="*{-,.,_}{EV8,EV7,EV6}{-,.,_}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*{EV8,EV7,EV6}*.spring";
        panelID="WES"
    break;

    case "WES":
        reads_pattern_cram="*{-,.,_}{EV8_ALM,EV8_ONK}{-,.,_}*.cram";
        reads_pattern_crai="*{-,.,_}{EV8_ALM,EV8_ONK}{-,.,_}*.crai";
        reads_pattern_fastq="*{-,.,_}{EV8_ALM,EV8_ONK}{-,.,_}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*{EV8_ALM,EV8_ONK}*.spring";
        panelID="WES_subpanel"
    break;

    case "WGS_CNV":
        reads_pattern_cram="*{-,.,_}{WG4_CNV}{-,.,_}*.cram";
        reads_pattern_crai="*{-,.,_}{WG4_CNV}{-,.,_}*.crai";
        reads_pattern_fastq="*{-,.,_}{WG4_CNV}{-,.,_}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*{WG4_CNV}*.spring";
        panelID="WGS"
    break;

    case "NGC":
        reads_pattern_cram="*{-,.,_}{WG4_NGC}{-,.,_}*.cram";
        reads_pattern_crai="*{-,.,_}{WG4_NGC}{-,.,_}*.crai";
        reads_pattern_fastq="*{-,.,_}{WG4_NGC}{-,.,_}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*{WG4_NGC}*.spring";
        panelID="WGS"
    break;

    default: 
        reads_pattern_cram="*{-,.,_}{WG3,WG4,A_WG4,LIB,WG4_CNV,WGSmerged,WG4_NGC}{-,.,_}*.cram";
        reads_pattern_crai="*{-,.,_}{WG3,WG4,A_WG4,LIB,WG4_CNV,WGSmerged,WG4_NGC}{-,.,_}*.crai";
        reads_pattern_fastq="*{-,.,_}{WG3,WG4,A_WG4,LIB,WG4_CNV,WGSmerged,WG4_NGC}{-,.,_}*R{1,2}*{fq,fastq}.gz";
        reads_pattern_spring="*{WG3,WG4,A_WG4,LIB,WG4_CNV,WGSmerged,WGS,nova,WG4_NGC}*.spring";
        panelID="WGS"
    break;
}



////////////////////////////////////////////////////
////// INPUT DATA (fastq or CRAM) channels //////////
////////////////////////////////////////////////////
/*
if (params.fastq) {
    params.reads="${params.fastq}/${reads_pattern_fastq}"
}
*/
if (!params.fastq && params.fastqInput) {

    params.reads="${dataArchive}/{lnx01,lnx02,kga01_novaRuns,tank_kga_external_archive}/**/${reads_pattern_fastq}"
}


// if fastq input, set reads input channels

// Standard use: point to fastq folder for paneldata

if (!params.samplesheet && params.fastq) {
// If NOT samplesheet (std panel run), set sampleID == NPN_PANEL_SUBPANEL

    params.reads="${params.fastq}/${reads_pattern_fastq}"
    //params.reads="${params.fastq}/*{.,_,-}{R1,R2}*.gz"
/*
 Channel
    .fromFilePairs(params.reads, checkIfExists: true)
    .ifEmpty { error "Cannot find any reads matching: ${params.reads}" }
//    .map { it -> [it[0]+"_"+params.panel+"_"+params.genome, file(it[1][0]),file(it[1][1])] }
    .map { it -> [it[0], file(it[1][0]),file(it[1][1])] }
    .set { read_pairs_ch }

*/

    Channel
    .fromPath(params.reads, checkIfExists: true)
    .filter {it =~/R1/}
    .map { tuple(it.baseName.tokenize('-').get(0)+"_"+it.baseName.tokenize('-').get(1),it) }
    .set { sampleid_R1}

    Channel
    .fromPath(params.reads, checkIfExists: true)
    .filter {it =~/R2/}
    .map { tuple(it.baseName.tokenize('-').get(0)+"_"+it.baseName.tokenize('-').get(1),it) }
    .set { sampleid_R2 }

    sampleid_R1.join(sampleid_R2)
    .set { read_pairs_ch }



}

if (params.samplesheet && params.fastq || params.fastqInput) {
    // If samplesheet, reduce sampleID to NPN only (no panel/subpanel info!)
    Channel
    .fromPath(params.reads, checkIfExists: true)
    .filter {it =~/_R1_/}
    //.map { tuple(it.baseName.tokenize('-').get(0),it) }
    .map { tuple(it.baseName.tokenize('-').get(0)+"_"+it.baseName.tokenize('-').get(1),it) }
    .set { sampleid_R1}

    Channel
    .fromPath(params.reads, checkIfExists: true)
    .filter {it =~/_R2_/}
    .map { tuple(it.baseName.tokenize('-').get(0)+"_"+it.baseName.tokenize('-').get(1),it) }
    //.map { tuple(it.baseName.tokenize('-').get(0),it) }
    .set { sampleid_R2 }

    sampleid_R1.join(sampleid_R2)
    .set { read_pairs_ch }

}


// Standard use: Point to fastq for WGS ana

if (params.cram) { //&& params.panel
    cramfiles="${params.cram}/${reads_pattern_cram}"
    craifiles="${params.cram}/${reads_pattern_crai}"

    Channel
    .fromPath(cramfiles)
    .map { tuple(it.baseName.tokenize('.').get(0),it) }
    .set { sampleID_cram }

    Channel
    .fromPath(craifiles)
    .map { tuple(it.baseName.tokenize('.').get(0),it) }
    .set {sampleID_crai }
}


// If only samplesheet is provided, use CRAM from archive as input (default setup)!

if (params.samplesheet && !params.cram && !params.fastqInput && !params.fastq) {
    cramfiles="${dataArchive}/{lnx01,lnx02,tank_kga_external_archive}/**/${reads_pattern_cram}"
    craifiles="${dataArchive}/{lnx01,lnx02,tank_kga_external_archive}/**/${reads_pattern_crai}"

    Channel
    .fromPath(cramfiles)
    .map { tuple(it.baseName.tokenize('_').get(0),it) }
    .set { sampleID_cram }

    Channel
    .fromPath(craifiles)
    .map { tuple(it.baseName.tokenize('_').get(0),it) }
    .set {sampleID_crai }
}

////////////////////////////////////////////////////////////////////
//// NEW June 2024: Add spring as input. ///////////////////////////
////////////////////////////////////////////////////////////////////


if (params.spring && !params.samplesheet) {

    params.spring_reads="${params.spring}/${reads_pattern_spring}"


    Channel
    .fromPath(params.spring_reads, checkIfExists: true)
    .map { tuple(it.baseName.tokenize('-').get(0)+"_"+it.baseName.tokenize('-').get(1),it) }
    .set {spring_input_ch}
}




////////////////////////////////////////////////////
///////////// SAMPLESHEET channels /////////////////
////////////////////////////////////////////////////
if (params.samplesheet) {
    channel.fromPath(params.samplesheet)
        .splitCsv(sep:'\t')
        .map { row -> tuple(row[1], row[0],row[2],row[3])}
        .set { full_samplesheet }
    //above: NPN, caseID, relation, samplestatus

    channel.fromPath(params.samplesheet)
        .splitCsv(sep:'\t')
        .map { row -> row[0]}
        .unique()
        .collect()
        .set { caseID_ch }

    channel.fromPath(params.samplesheet)
        .splitCsv(sep:'\t')
        .map { row -> tuple(row[0],row[1])}
        .set {caseID_sampleID}
}


////////////////////////////////////////////////////
///////////// set final input channels   ///////////
////////////////////////////////////////////////////


if (!params.samplesheet && params.fastq) {
    read_pairs_ch
    .set { fq_read_input }
}

if (!params.samplesheet && params.cram) {
    sampleID_cram.join(sampleID_crai)
    .set { meta_aln_index }
}

if (params.samplesheet && !params.cram && (params.fastqInput||params.fastq)) {
    full_samplesheet.join(read_pairs_ch)
    .map {tuple (it[0]+"_"+it[1]+"_"+it[2],it[4],it[5])}
    .set { fq_read_input }
}

if (params.samplesheet && !params.fastqInput && !params.fastq) {

    full_samplesheet.join(sampleID_cram).join(sampleID_crai)
    .map {tuple (it[0]+"_"+it[1]+"_"+it[2],it[4],it[5])}
    .set {meta_aln_index}
}


// mean depth
// 1) Flatten meta_aln_index -> (sampleID, cramFile)
//
Channel
    .from(meta_aln_index)
    .map { sampleID1, cramFile, sampleID2, craiFile ->
        tuple(sampleID1, cramFile)
    }
    .set { meta_aln_index_depth }

//
// 2) The calcMeanDepth process
//
process calcMeanDepth {
    tag "$sampleID"

    input:
        tuple val(sampleID), file(cramFile)

    output:
        tuple val(sampleID), file("mean_depth.txt")

    script:
    """
    samtools depth -a ${cramFile} \\
      | awk '{sum += \$3} END {if (NR>0) print sum/NR; else print 0}' > mean_depth.txt
    """
}


//////// END: Combine input and samplesheet //////////

///// Haplotypecaller splitintervals channel: /////
/*
channel
    .fromPath(params.intervals_list)
    .map { it -> tuple(it.baseName,it)}
    .set { haplotypecallerIntervalList }
*/
////////////////////////////////////////////////////

include { 
         // Symlinks:
         inputFiles_symlinks_cram;
         inputFiles_cramCopy;
         // Preprocess tools:
         //QC tools
         samtools;
         qualimap;
         fastqc_bam;
         collectWGSmetrics;
         multiQC;
         vntyper_newRef;
         //subworkflows:
         SUB_SPRING_DECOMPRESS;
         SUB_PREPROCESS;
         SUB_VARIANTCALL;
         SUB_VARIANTCALL_WGS;
         SUB_CNV_SV;
         SUB_STR;
         SUB_SMN } from "./modules/modules.dna.v1.nf" 


workflow QC {
    take: 
    meta_aln_index
    main:
    samtools(meta_aln_index)
//    qualimap(meta_aln_index)
//    fastqc_bam(meta_aln_index)
    multiQC(samtools.out.ifEmpty([]).mix(qualimap.out.ifEmpty([])).mix(fastqc_bam.out.ifEmpty([])).collect())

}



workflow {

    if (params.spring) {
        SUB_SPRING_DECOMPRESS(spring_input_ch)
        //SUB_SPRING_DECOMPRESS.out.view()
        fq_read_input=SUB_SPRING_DECOMPRESS.out.fq_read_input_spring
    }

    if (params.fastqInput||params.fastq||params.spring || params.preprocessOnly) {
        SUB_PREPROCESS(fq_read_input)
        meta_aln_index=SUB_PREPROCESS.out.finalAln
        
    }

    if (!params.preprocessOnly) {
        if (!params.fastqInput && !params.fastq && !params.spring) {
            inputFiles_symlinks_cram(meta_aln_index)
        }

        if (!params.panel || params.panel =="WGS_CNV"|| params.panel =="NGC") { //i.e. if WGS data

            if (!params.skipVariants) {
                SUB_VARIANTCALL_WGS(meta_aln_index)
            }
            if (!params.skipSV) {
                SUB_CNV_SV(meta_aln_index)
            }
            if (!params.skipSTR) {
                SUB_STR(meta_aln_index)
            }
            
            if (!params.skipSMN) {
            SUB_SMN(meta_aln_index)
            }

        }

        if (params.panel && params.panel!="WGS_CNV"&& params.panel!="NGC") {

            SUB_VARIANTCALL(meta_aln_index)

            if (params.panel=="MV1") {
                vntyper_newRef(fq_read_input)
            }
        }
    }
}


/*

workflow (works with spring) {

    if (params.spring) {
        SUB_SPRING_DECOMPRESS(spring_input_ch)
        //SUB_SPRING_DECOMPRESS.out.view()
        fq_read_input=SUB_SPRING_DECOMPRESS.out.fq_read_input_spring
    }

    if (!params.panel || params.panel =="WGS_CNV") { 

        if (params.fastqInput||params.fastq) {


            SUB_PREPROCESS(fq_read_input)
          
            if (!params.preprocessOnly) {
                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(SUB_PREPROCESS.out.finalAln)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(SUB_PREPROCESS.out.finalAln)
                }
                if (!params.skipSTR) {
                    SUB_STR(SUB_PREPROCESS.out.finalAln)
                }
                
                if (!params.skipSMN) {
                SUB_SMN(SUB_PREPROCESS.out.finalAln)
                }
            }
        }

        if (!params.fastqInput && !params.fastq && !params.spring) {

            if (!params.copyCram) {
                inputFiles_symlinks_cram(meta_aln_index)

                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(meta_aln_index)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(meta_aln_index)
                }
                if (!params.skipSTR) {
                    SUB_STR(meta_aln_index)
                }
                if (!params.skipSMN) {
                SUB_SMN(meta_aln_index)
                }
            }

            if (params.copyCram) {
                inputFiles_symlinks_cram(meta_aln_index)
                inputFiles_cramCopy(meta_aln_index)
            
                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(inputFiles_cramCopy.out)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(inputFiles_cramCopy.out)
                }
                if (!params.skipSTR) {
                    SUB_STR(inputFiles_cramCopy.out)
                }
                if (!params.skipSMN) {
                    SUB_SMN(inputFiles_cramCopy.out)
                }
            }
        }
    }

    if (params.panel && params.panel!="WGS_CNV") {

        if (params.fastqInput||params.fastq || params.spring) {
            SUB_PREPROCESS(fq_read_input)
            SUB_VARIANTCALL(SUB_PREPROCESS.out.finalAln)

            if (params.panel=="MV1") {
                vntyper_newRef(fq_read_input)
            }
        }

        if (!params.fastqInput && !params.fastq && !params.spring) {
            inputFiles_symlinks_cram(meta_aln_index)
            SUB_VARIANTCALL(meta_aln_index)
        }
    }
}


*/


/*
workflow {

    if (params.spring) {
        workflow SUB_SPRING_DECOMPRESS(spring_input_ch)
    }

    if (!params.panel || params.panel =="WGS_CNV") { 

        if (params.fastqInput||params.fastq) {


            SUB_PREPROCESS(fq_read_input)
          
            if (!params.preprocessOnly) {
                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(SUB_PREPROCESS.out.finalAln)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(SUB_PREPROCESS.out.finalAln)
                }
                if (!params.skipSTR) {
                    SUB_STR(SUB_PREPROCESS.out.finalAln)
                }
                
                if (!params.skipSMN) {
                SUB_SMN(SUB_PREPROCESS.out.finalAln)
                }
            }
        }

        if (!params.fastqInput && !params.fastq && !params.spring) {

            if (!params.copyCram) {
                inputFiles_symlinks_cram(meta_aln_index)

                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(meta_aln_index)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(meta_aln_index)
                }
                if (!params.skipSTR) {
                    SUB_STR(meta_aln_index)
                }
                if (!params.skipSMN) {
                SUB_SMN(meta_aln_index)
                }
            }

            if (params.copyCram) {
                // 1) Function-call style: pass meta_aln_index_depth
                    calcMeanDepth(meta_aln_index_depth)
                        .set { meanDepthChannel }
                
                // 2) Collect results to build a summary
                def meanDepthSummary = ''
                meanDepthChannel.collect().subscribe { results ->
                    meanDepthSummary = results.collect { sampleID, depthFile ->
                        def depthVal = depthFile.text.trim()
                        return "${sampleID}: ${depthVal}X"
                    }.join('\n')
                }

                inputFiles_symlinks_cram(meta_aln_index)
                inputFiles_cramCopy(meta_aln_index)
            
                if (!params.skipVariants) {
                    SUB_VARIANTCALL_WGS(inputFiles_cramCopy.out)
                }
                if (!params.skipSV) {
                    SUB_CNV_SV(inputFiles_cramCopy.out)
                }
                if (!params.skipSTR) {
                    SUB_STR(inputFiles_cramCopy.out)
                }
                if (!params.skipSMN) {
                    SUB_SMN(inputFiles_cramCopy.out)
                }
            }
        }
    }

    if (params.panel && params.panel!="WGS_CNV") {

        if (params.fastqInput||params.fastq) {
            SUB_PREPROCESS(fq_read_input)
            SUB_VARIANTCALL(SUB_PREPROCESS.out.finalAln)

            if (params.panel=="MV1") {
                vntyper_newRef(fq_read_input)
            }
        }

        if (!params.fastqInput && !params.fastq) {
            inputFiles_symlinks_cram(meta_aln_index)
            SUB_VARIANTCALL(meta_aln_index)
        }
    }
}




/* -----------------------------------------------------------------
   ON COMPLETE: send email with sample names, etc.
   ----------------------------------------------------------------- */
workflow.onComplete {
    println("Mean Depth Summary:")
    println(meanDepthSummary)
    def currentYear = new Date().format('yyyy')

    // (Optional) If you have an IP file for lnx02 emailing:
    def ipFilePath = '/lnx01_data2/shared/testdata/test_scripts/ip_file'
    def ip = ""
    if (params.server == 'lnx02') {
        if (new File(ipFilePath).exists()) {
            ip = new File(ipFilePath).text.trim()
        } else {
            println "Warning: IP file not found at ${ipFilePath}, might fail sending email from lnx02."
        }
    }

    // Build the sample names string
    def sampleNamesString = sampleNamesList.join('\n')

    // Email conditions: pipeline success, duration > 5 minutes(300000), user is "mmaj" or "raspau", etc.
    if (!params.nomail && workflow.success && workflow.duration > 3) {
        if (user in ["mmaj", "raspau"]) {

            // Example: derive "sequencingRun" from the CRAM folder name
            def sequencingRun = params.cram
                ? new File(params.cram).getName().take(6)
                : params.fastq
                    ? new File(params.fastq).getName().take(6)
                    : 'Not provided'

            // Check for OBS sample if panel == AV1
            def obsSampleMessage = ""
            if (params.panel == "AV1" && params.cram) {
                def cramDir = new File(params.cram)
                def obsSamples = cramDir.listFiles().findAll { it.name.contains("OBS") }
                if (obsSamples.size() > 0) {
                    obsSampleMessage = "\nTHERE IS AN OBS SAMPLE IN THIS RUN"
                }
            }

            def workDirMessage = params.keepwork ? "WorkDir: ${workflow.workDir}" : "WorkDir: Deleted"
            def outputDir = "${launchDir}/${launchDir.baseName}.Results"

            def body = """|Pipeline execution summary
                          |---------------------------
                          |Pipeline completed: ${params.panel}
                          |Sequencing run: ${sequencingRun}${obsSampleMessage}
                          |Duration: ${workflow.duration}
                          |Success: ${workflow.success}
                          |WorkDir: ${workDirMessage}
                          |OutputDir: ${outputDir}
                          |Exit status: ${workflow.exitStatus}
                          |
                          |Samples included in the pipeline:
                          |${sampleNamesString}
                          |
                          |Mean Depth per Sample:
                          |${meanDepthSummary}
                          """.stripMargin('|')

            // Example recipients
            def recipients = 'Rasmus.Hojrup.Pausgaard@rsyd.dk'

            // Send mail depending on server
            if (params.server == 'lnx01') {
                // Nextflow's built-in mail
                sendMail(to: recipients, subject: 'CRAM-based pipeline Update', body: body)
            }
            else if (params.server == 'lnx02') {
                // Use external command
                def emailCommand = "ssh ${ip} 'echo \"${body}\" | mail -s \"CRAM-based pipeline Update\" ${recipients}'"
                def proc = ['bash', '-c', emailCommand].execute()
                proc.waitFor()
                if (proc.exitValue() != 0) {
                    println("Error sending email from lnx02: ${proc.err.text}")
                } else {
                    println("Email successfully sent from lnx02.")
                }
            }

            // Move WGS_CNV from lnx02 to lnx01 if success
            if (params.server == 'lnx02' && params.panel == 'WGS_CNV' && workflow.success) {
                def moveWGSCNVCommand = "mv ${launchDir} /lnx01_data2/shared/patients/hg38/WGS.CNV/${currentYear}/"
                def moveWGSCNVProcess = ['bash', '-c', moveWGSCNVCommand].execute()
                moveWGSCNVProcess.waitFor()
                if (moveWGSCNVProcess.exitValue() != 0) {
                    println("Error moving WGS_CNV files: ${moveWGSCNVProcess.err.text}")
                }
            }

            // Move WGS_NGC from lnx02 to lnx01 if success
            if (params.server == 'lnx02' && params.panel == 'NGC' && workflow.success) {
                def moveWGSNGCCommand = "mv ${launchDir} /lnx01_data2/shared/patients/hg38/WGS_NGC/${currentYear}/"
                def moveWGSNGCProcess = ['bash', '-c', moveWGSNGCCommand].execute()
                moveWGSNGCProcess.waitFor()
                if (moveWGSNGCProcess.exitValue() != 0) {
                    println("Error moving WGS_NGC files: ${moveWGSNGCProcess.err.text}")
                }
            }

            // Move WES from lnx02 to lnx01 if success
            if (params.server == 'lnx02' && params.panel == 'WES' && workflow.success) {
                def moveWESCommand = "mv ${launchDir} /lnx01_data2/shared/patients/hg38/WES_ALM_ONK/${currentYear}/"
                def moveWESProcess = ['bash', '-c', moveWESCommand].execute()
                moveWESProcess.waitFor()
                if (moveWESProcess.exitValue() != 0) {
                    println("Error moving WES files: ${moveWESProcess.err.text}")
                }
            }
        }
    }

    // Delete work directory if not keeping it
    if (!params.keepwork) {
        println("Deleting work directory: ${workflow.workDir}")
        def deleteWorkDirCommand = "rm -rf ${workflow.workDir}".execute()
        deleteWorkDirCommand.waitFor()
        if (deleteWorkDirCommand.exitValue() != 0) {
            println("Error deleting work directory: ${deleteWorkDirCommand.err.text}")
        }
    }
}
